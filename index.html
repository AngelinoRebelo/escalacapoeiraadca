<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escala de Cultos e Serviços (ADCA)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
        }
        /* Estilos para células editáveis */
        [contenteditable="true"] {
            outline: none;
            border: 2px dashed #3b82f6; /* Borda azul para indicar que é editável */
            border-radius: 4px;
            cursor: pointer;
        }
        /* Estilo para a linha de cabeçalho da semana */
        .week-header {
            background-color: #3b82f6 !important;
            color: white;
            font-weight: 700;
            text-align: center;
            font-size: 1.125rem; /* text-lg */
        }
        /* Estilo para a célula que simula o datalist (apenas visual) */
        .editable-cell-container {
            position: relative;
            /* Garante que o input e a lista de sugestão se encaixem */
        }

        /* Esconder o input real do datalist, pois usamos contenteditable */
        .datalist-input {
            width: 100%;
            border: none;
            background: transparent;
            outline: none;
            display: none; /* Ocultamos o input real e deixamos o contenteditable */
        }
        /* Esconder o scrollbar para melhorar a estética da tabela em telas pequenas */
        .schedule-container::-webkit-scrollbar {
            display: none;
        }
        .schedule-container {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        /* Fix para garantir que o datalist se sobreponha a outros elementos */
        .autocomplete-container {
            position: absolute;
            z-index: 10;
            width: 100%;
            background-color: white;
            border: 1px solid #ccc;
            max-height: 150px;
            overflow-y: auto;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
        .autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            text-align: left;
        }
        .autocomplete-item:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <!-- Cabeçalho Principal e Seleção de Mes/Ano -->
    <header class="mb-6 p-4 flex flex-col md:flex-row items-center justify-between bg-white rounded-lg shadow-md">
        <h1 class="text-2xl font-bold text-gray-800">ESCALA DE CULTOS</h1>

        <div class="flex items-center space-x-3 mt-4 md:mt-0">
            <select id="monthSelector" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500"></select>
            <select id="yearSelector" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500"></select>
            
            <button id="authButton" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                Login Admin
            </button>
            <button id="adminManagerButton" class="hidden bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 ml-3">
                Gerenciar Escala
            </button>
        </div>
    </header>

    <!-- Indicador de Status/Loading -->
    <div id="statusMessage" class="text-center p-4 mb-6 hidden font-medium rounded-lg shadow-md"></div>

    <!-- Tabela da Escala Principal -->
    <div id="scheduleContainer" class="overflow-x-auto bg-white p-4 rounded-lg shadow-lg">
        <table id="scheduleTable" class="min-w-full divide-y divide-gray-200">
            <thead class="bg-blue-600 text-white sticky top-0 shadow-lg z-10">
                <tr>
                    <th scope="col" class="px-3 py-3 text-left text-xs font-semibold uppercase tracking-wider w-1/12">DATA</th>
                    <th scope="col" class="px-3 py-3 text-left text-xs font-semibold uppercase tracking-wider w-1/12">DIA</th>
                    <th scope="col" class="px-3 py-3 text-left text-xs font-semibold uppercase tracking-wider w-2/12">CULTO</th>
                    <th scope="col" class="px-3 py-3 text-left text-xs font-semibold uppercase tracking-wider w-3/12">PORTARIA</th>
                    <th scope="col" class="px-3 py-3 text-left text-xs font-semibold uppercase tracking-wider w-3/12">DIREÇÃO</th>
                    <th scope="col" class="px-3 py-3 text-left text-xs font-semibold uppercase tracking-wider w-3/12">PRELETOR</th>
                </tr>
            </thead>
            <tbody id="scheduleBody" class="divide-y divide-gray-100">
                <!-- Linhas de escala serão inseridas aqui pelo JavaScript -->
            </tbody>
        </table>
    </div>

    <!-- MODAIS -->

    <!-- Modal de Login/Primeiro Acesso Admin (Email/Senha) -->
    <div id="authModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-sm transform transition-all duration-300">
            <h2 id="authModalTitle" class="text-2xl font-bold mb-4 text-center text-gray-800">Login Admin</h2>
            <form id="authForm" class="space-y-4">
                <div>
                    <label for="adminEmail" class="block text-sm font-medium text-gray-700">Email</label>
                    <input type="email" id="adminEmail" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div>
                    <label for="adminPassword" class="block text-sm font-medium text-gray-700">Senha</label>
                    <input type="password" id="adminPassword" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                </div>
                <button type="submit" id="authSubmitButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                    Acessar
                </button>
            </form>
            <button onclick="closeModal('authModal')" class="w-full mt-3 text-sm text-gray-500 hover:text-gray-700">Fechar</button>
        </div>
    </div>


    <!-- Modal de Gerenciamento Administrativo (Membros e Cultos) -->
    <div id="adminManagerModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-4xl transform transition-all duration-300 max-h-[90vh] overflow-y-auto">
            <h2 class="text-3xl font-bold mb-6 text-gray-800 text-center">Gerenciamento Administrativo</h2>
            
            <!-- 1. Gerenciamento de Membros -->
            <div class="mb-8 border-b pb-4">
                <h3 class="text-xl font-semibold mb-3 text-blue-600">1. Gerenciar Membros</h3>
                <div class="flex space-x-3 mb-4">
                    <input type="text" id="newMemberName" placeholder="Nome do Novo Membro" class="flex-grow px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
                    <button id="addMemberButton" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                        Adicionar
                    </button>
                </div>
                <div id="membersList" class="space-y-2 max-h-40 overflow-y-auto p-2 border rounded-lg bg-gray-50">
                    <!-- Lista de Membros aqui -->
                </div>
            </div>

            <!-- 2. Adicionar Culto Manualmente -->
            <div class="mb-8 border-b pb-4">
                <h3 class="text-xl font-semibold mb-3 text-blue-600">2. Adicionar Culto ao Mês Atual</h3>
                <form id="addCultoForm" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <label for="cultoDate" class="block text-sm font-medium text-gray-700">Data do Culto</label>
                        <input type="date" id="cultoDate" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div>
                        <label for="cultoName" class="block text-sm font-medium text-gray-700">Nome do Culto</label>
                        <input type="text" id="cultoName" required value="DOUTRINA" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div class="flex items-end">
                        <button type="submit" id="addCultoSubmitButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                            Adicionar Linha
                        </button>
                    </div>
                </form>
            </div>
            
            <!-- 3. Configurações Admin -->
            <div class="mb-8 border-b pb-4">
                <h3 class="text-xl font-semibold mb-3 text-blue-600">3. Configurações Admin</h3>
                <p class="text-sm text-gray-600 mb-2">Altere seu email e/ou senha de administrador.</p>
                <form id="updateAdminForm" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <label for="adminNewEmail" class="block text-sm font-medium text-gray-700">Novo Email (Opcional)</label>
                        <input type="email" id="adminNewEmail" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div>
                        <label for="adminNewPassword" class="block text-sm font-medium text-gray-700">Nova Senha (Opcional)</label>
                        <input type="password" id="adminNewPassword" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div class="flex items-end">
                        <button type="submit" class="w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                            Atualizar
                        </button>
                    </div>
                </form>
                <p id="updateStatus" class="mt-3 text-sm font-medium"></p>
            </div>

            <button onclick="closeModal('adminManagerModal')" class="w-full mt-4 bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                Fechar
            </button>
        </div>
    </div>

    <!-- Datalist para Autocomplete de Membros (Obrigatório para seleção de nomes) -->
    <datalist id="members-datalist">
        <!-- Options serão inseridas aqui via JavaScript -->
    </datalist>

    <!-- Firebase e Lógica JavaScript -->
    <script type="module">
        import { initializeApp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            signOut,
            onAuthStateChanged,
            updateEmail,
            updatePassword
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            onSnapshot, 
            collection, 
            query, 
            getDoc,
            deleteDoc,
            updateDoc
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // setLogLevel('debug'); // Descomente para debugar o Firebase no console

        // Variáveis globais de ambiente (fornecidas pelo Canvas)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : `{
            "apiKey": "AIzaSyAIVZC5Q8lfcMPCiv1oQzFm1oCajNB76c8",
            "authDomain": "escala-adca-capoeira.firebaseapp.com",
            "projectId": "escala-adca-capoeira",
            "storageBucket": "escala-adca-capoeira.firebasestorage.app",
            "messagingSenderId": "1015575781500",
            "appId": "1:1015575781500:web:1c483c568b98dfd5cd29f9"
        }`);

        // Inicialização do Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // Referências DOM
        const statusMessage = document.getElementById('statusMessage');
        const scheduleBody = document.getElementById('scheduleBody');
        const monthSelector = document.getElementById('monthSelector');
        const yearSelector = document.getElementById('yearSelector');
        const authButton = document.getElementById('authButton');
        const adminManagerButton = document.getElementById('adminManagerButton');
        
        const authModal = document.getElementById('authModal');
        const adminManagerModal = document.getElementById('adminManagerModal');
        const authForm = document.getElementById('authForm');
        const authModalTitle = document.getElementById('authModalTitle');
        const authSubmitButton = document.getElementById('authSubmitButton');
        
        const membersDatalist = document.getElementById('members-datalist');
        const membersListContainer = document.getElementById('membersList');
        const newMemberNameInput = document.getElementById('newMemberName');
        const addMemberButton = document.getElementById('addMemberButton');

        // Estado do Aplicativo
        let currentYear = new Date().getFullYear();
        let currentMonth = new Date().getMonth(); // 0 a 11
        let isAdmin = false;
        let members = [];
        let adminConfig = null;

        const ADMIN_CONFIG_DOC = doc(db, `artifacts/${appId}/public/data/config/admin`);
        const MEMBERS_COLLECTION = collection(db, `artifacts/${appId}/public/data/members`);
        const SCHEDULE_COLLECTION = collection(db, `artifacts/${appId}/public/data/schedule`);

        const CULTOS_PADRAO = {
            3: "DOUTRINA", // Quarta-feira
            5: "LIBERTAÇÃO", // Sexta-feira
            0: "LOUVOR E ADORAÇÃO" // Domingo
        };

        // --- Funções Utilitárias ---

        /** Exibe mensagens de status na tela */
        const showStatus = (message, isError = false) => {
            statusMessage.textContent = message;
            statusMessage.classList.remove('hidden');
            statusMessage.className = `text-center p-4 mb-6 font-medium rounded-lg shadow-md`;
            if (isError) {
                statusMessage.classList.add('bg-red-100', 'text-red-800', 'border', 'border-red-400');
            } else {
                statusMessage.classList.add('bg-green-100', 'text-green-800');
            }
            setTimeout(() => statusMessage.classList.add('hidden'), 5000);
        };

        /** Fecha o modal */
        const closeModal = (id) => {
            document.getElementById(id).classList.add('hidden');
        };
        
        /** Converte a data para um identificador de semana */
        const getWeekNumber = (d) => {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return weekNo;
        };

        /** Retorna o nome do dia da semana em português */
        const getDayName = (dayIndex) => {
            return ["DOMINGO", "SEGUNDA-FEIRA", "TERÇA-FEIRA", "QUARTA-FEIRA", "QUINTA-FEIRA", "SEXTA-FEIRA", "SÁBADO"][dayIndex];
        };

        /** Retorna o nome do mês em português */
        const getMonthName = (monthIndex) => {
            return ["JANEIRO", "FEVEREIRO", "MARÇO", "ABRIL", "MAIO", "JUNHO", "JULHO", "AGOSTO", "SETEMBRO", "OUTUBRO", "NOVEMBRO", "DEZEMBRO"][monthIndex];
        };
        
        /** Gera uma chave única de documento para a escala */
        const getScheduleDocId = (month, year) => `schedule-${year}-${String(month + 1).padStart(2, '0')}`;

        // --- Lógica de Inicialização de Dados ---

        /** Inicializa a lista de membros padrão se não houver nenhum */
        const initializeMembers = async () => {
             const defaultMembers = [
                "Pr. Gabriel", "Prb. Leandro", "Miss. Ana", "Miss. Kelly", "Miss. Lorrane", 
                "Miss. Ester", "Dca. Simone", "Dca. Rosa", "Dca. Raquel", "Dca. Cristiane", 
                "Ob. Janete", "Ob. Ana Rocha", "Ob. Marcos", "Ob. Clemiltom", "Ir. Vitória", 
                "Ir. Natalia", "Ir. Gabriel"
            ];
             try {
                const membersSnapshot = await getDoc(doc(MEMBERS_COLLECTION, 'default-members'));
                if (!membersSnapshot.exists()) {
                    await setDoc(doc(MEMBERS_COLLECTION, 'default-members'), { names: defaultMembers });
                }
             } catch (error) {
                console.warn("Aviso: Falha ao inicializar membros. Regras de escrita devem ser 'if request.auth != null'.", error);
             }
        };

        /** Inicializa a escala do mês/ano se não existir */
        const initializeSchedule = async (month, year) => {
            const docId = getScheduleDocId(month, year);
            const docRef = doc(SCHEDULE_COLLECTION, docId);
            
            try {
                const docSnap = await getDoc(docRef);

                if (!docSnap.exists()) {
                    showStatus(`Gerando escala inicial para ${getMonthName(month)}/${year}...`, false);
                    
                    const newSchedule = [];
                    const firstDayOfMonth = new Date(year, month, 1);
                    const lastDayOfMonth = new Date(year, month + 1, 0);

                    for (let d = firstDayOfMonth; d <= lastDayOfMonth; d.setDate(d.getDate() + 1)) {
                        const day = d.getDay(); // 0=Domingo, 3=Quarta, 5=Sexta
                        
                        if (CULTOS_PADRAO[day]) {
                            const dateString = `${String(d.getDate()).padStart(2, '0')}/${String(d.getMonth() + 1).padStart(2, '0')}/${d.getFullYear()}`;
                            
                            // Cria um ID único baseado na data e tipo de culto
                            const cultoId = `${year}-${String(month + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}-${day}`;

                            newSchedule.push({
                                id: cultoId,
                                date: dateString,
                                day: getDayName(day),
                                culto: CULTOS_PADRAO[day],
                                portaria: "A DEFINIR",
                                direcao: "A DEFINIR",
                                preletor: "A DEFINIR",
                                timestamp: d.getTime(), // Para ordenação
                                week: getWeekNumber(d)
                            });
                        }
                    }

                    if (newSchedule.length > 0) {
                         await setDoc(docRef, { cultos: newSchedule });
                         showStatus(`Escala de ${getMonthName(month)}/${year} gerada com sucesso!`, false);
                    } else {
                         showStatus(`Não há cultos padrões para gerar em ${getMonthName(month)}/${year}.`, false);
                    }
                }
            } catch (error) {
                 console.warn("Aviso: Falha ao inicializar a escala. Regras de escrita devem ser 'if request.auth != null'.", error);
            }
        };

        // --- Lógica de Renderização ---

        /** Cria a célula editável com datalist */
        const createEditableCell = (culto, field, value) => {
            const displayValue = value || "A DEFINIR";
            
            // Usamos um campo de input com datalist para permitir a seleção de nomes pré-definidos.
            if (isAdmin) {
                return `
                <td class="px-3 py-2 text-sm text-gray-900 editable-cell-container relative">
                    <input 
                        type="text" 
                        value="${displayValue}" 
                        data-id="${culto.id}" 
                        data-field="${field}" 
                        list="members-datalist"
                        class="datalist-input block w-full px-1 py-0.5 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                        onfocus="this.select()"
                        onblur="saveScheduleChange(this, '${culto.id}', '${field}')"
                        onkeypress="if(event.key === 'Enter') { event.preventDefault(); this.blur(); }"
                        style="display: block;"
                    />
                    <datalist id="members-datalist">
                        <!-- Será preenchida dinamicamente -->
                    </datalist>
                </td>`;
            } else {
                 return `<td class="px-3 py-2 text-sm text-gray-900">${displayValue}</td>`;
            }
        };

        /** Cria uma linha da tabela de escala */
        const createScheduleRow = (culto, isFirstOfWeek, isEvenWeek) => {
            const baseRowClass = isEvenWeek ? 'bg-gray-50 hover:bg-gray-200' : 'bg-white hover:bg-gray-200';
            
            let html = '';
            
            // Linha de cabeçalho da semana
            if (isFirstOfWeek) {
                const monthName = getMonthName(currentMonth);
                const weekNumber = culto.week - getWeekNumber(new Date(currentYear, currentMonth, 1)) + 1;
                html += `
                    <tr class="week-header">
                        <td colspan="6" class="px-3 py-2">
                            ${weekNumber > 0 ? `SEMANA ${weekNumber}` : 'PRIMEIROS DIAS'} DE ${monthName}
                        </td>
                    </tr>
                `;
            }

            // Linha do culto
            html += `
                <tr id="culto-${culto.id}" class="${baseRowClass} transition duration-150 ease-in-out">
                    <td class="px-3 py-2 text-xs font-semibold text-blue-800">${culto.date}</td>
                    <td class="px-3 py-2 text-xs font-semibold text-blue-800">${culto.day}</td>
                    <td class="px-3 py-2 text-sm font-medium text-gray-900">${culto.culto}</td>
                    
                    ${createEditableCell(culto, 'portaria', culto.portaria)}
                    ${createEditableCell(culto, 'direcao', culto.direcao)}
                    ${createEditableCell(culto, 'preletor', culto.preletor)}
                    
                    <!-- Botão de exclusão visível apenas para Admin -->
                    ${isAdmin ? `
                        <td class="px-2 py-2 w-1/12">
                            <button onclick="deleteCulto('${culto.id}')" class="text-red-600 hover:text-red-900 text-sm font-semibold">
                                X
                            </button>
                        </td>
                    ` : ''}
                </tr>
            `;
            return html;
        };
        
        /** Ordena a escala: por semana, depois por dia (Domingo, Quarta, Sexta) */
        const sortSchedule = (cultos) => {
            return cultos.sort((a, b) => {
                const dateA = new Date(a.timestamp);
                const dateB = new Date(b.timestamp);
                
                // 1. Ordena por data (para agrupar semanas)
                if (dateA.getTime() !== dateB.getTime()) {
                    return dateA - dateB;
                }

                // 2. Ordena por dia da semana (Domingo=0, Quarta=3, Sexta=5) para manter a prioridade
                const dayOrder = { 0: 1, 3: 2, 5: 3 }; // Define a ordem: Dom > Qua > Sex
                const dayA = new Date(a.timestamp).getDay();
                const dayB = new Date(b.timestamp).getDay();

                return (dayOrder[dayA] || 99) - (dayOrder[dayB] || 99);
            });
        };

        /** Renderiza a tabela da escala */
        const renderSchedule = (cultosData) => {
            const sortedCultos = sortSchedule(cultosData);
            scheduleBody.innerHTML = '';
            
            if (sortedCultos.length === 0) {
                 scheduleBody.innerHTML = `<tr><td colspan="6" class="p-4 text-center text-gray-500">Nenhum culto agendado para este mês.</td></tr>`;
                 return;
            }

            let lastWeek = null;
            let isEvenWeek = false;

            sortedCultos.forEach((culto) => {
                const cultoDate = new Date(culto.timestamp);
                const currentWeek = getWeekNumber(cultoDate);
                const isFirstOfWeek = lastWeek === null || currentWeek !== lastWeek;

                if (isFirstOfWeek) {
                    isEvenWeek = !isEvenWeek;
                    lastWeek = currentWeek;
                }

                const rowHtml = createScheduleRow(culto, isFirstOfWeek, isEvenWeek);
                scheduleBody.insertAdjacentHTML('beforeend', rowHtml);
            });
            
            // Recria a lógica de datalist para todas as novas células
            setupDatalistLogic();
        };
        
        /** Configura a lógica de Datalist (autocomplete) */
        const setupDatalistLogic = () => {
             // 1. Atualiza o Datalist global
             membersDatalist.innerHTML = members.map(name => `<option value="${name}">`).join('');
            
            // 2. Garante que todas as células editáveis usem o datalist
            document.querySelectorAll('.datalist-input').forEach(input => {
                // Apenas garante que o input está visível para edição
                if(isAdmin) {
                    input.style.display = 'block';
                    input.setAttribute('list', 'members-datalist');
                } else {
                    // Se não for admin, exibe o valor em texto
                    input.style.display = 'none';
                    const displayDiv = document.createElement('div');
                    displayDiv.textContent = input.value;
                    input.parentNode.appendChild(displayDiv);
                }
            });
        };
        
        // --- Lógica de Persistência ---

        /** Salva a alteração de um campo no Firestore (Portaria, Direção, Preletor) */
        window.saveScheduleChange = async (element, cultoId, field) => {
            if (!isAdmin) return;
            
            // Garante que o input contenha o valor
            const newValue = element.value.trim();

            const month = currentMonth;
            const year = currentYear;
            const docId = getScheduleDocId(month, year);
            const docRef = doc(SCHEDULE_COLLECTION, docId);
            
            try {
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const cultos = docSnap.data().cultos;
                    const cultoIndex = cultos.findIndex(c => c.id === cultoId);

                    if (cultoIndex !== -1) {
                        cultos[cultoIndex][field] = newValue;
                        await updateDoc(docRef, { cultos: cultos });
                        // O onSnapshot se encarrega de renderizar
                    }
                }
            } catch (error) {
                showStatus(`Erro ao salvar: ${error.message}`, true);
                console.error("Erro ao salvar alteração no Firestore:", error);
            }
        };

        /** Exclui um culto (linha da tabela) */
        window.deleteCulto = async (cultoId) => {
            if (!isAdmin) {
                showStatus("Permissão negada. Faça login como Admin para excluir.", true);
                return;
            }
            if (!window.confirm("Tem certeza que deseja remover este culto da escala?")) return;

            const docId = getScheduleDocId(currentMonth, currentYear);
            const docRef = doc(SCHEDULE_COLLECTION, docId);
            
            try {
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const cultos = docSnap.data().cultos.filter(c => c.id !== cultoId);
                    await setDoc(docRef, { cultos: cultos }); // Usamos setDoc para substituir o array
                    showStatus("Culto removido com sucesso!", false);
                }
            } catch (error) {
                showStatus(`Erro ao remover culto: ${error.message}`, true);
                console.error("Erro ao remover culto:", error);
            }
        };
        
        // --- Listeners de Dados em Tempo Real ---

        /** Configura o listener para o Admin Config e Membros */
        const setupGlobalListeners = () => {
            // Listener para Config Admin (para botão de "Primeiro Acesso")
            onSnapshot(ADMIN_CONFIG_DOC, (docSnap) => {
                if (docSnap.exists()) {
                    adminConfig = docSnap.data();
                } else {
                    // Garante que o documento existe para evitar erros de leitura
                    adminConfig = { password: 'DEFAULT_PASSWORD' };
                }
                updateAuthButton();
            }, (error) => {
                 console.error("Erro ao ler config Admin:", error);
                 // Mensagem de Erro com instrução ideal para a regra de leitura
                 statusMessage.innerHTML = `
                    <p><strong>Atenção: Erro de Permissão do Firebase</strong></p>
                    <p>Para iniciar, você precisa ALTERAR A REGRA DE SEGURANÇA no Firebase para permitir a leitura pública dos dados iniciais:</p>
                    <pre class="bg-red-200 p-2 mt-2 rounded"><code>match /artifacts/{appId}/public/data/{document=**} {
  allow read: if true;
  allow write: if request.auth != null;
}</code></pre>
                 `;
                 statusMessage.classList.remove('hidden');
                 statusMessage.classList.add('bg-red-100', 'text-red-800', 'border', 'border-red-400');
            });
            
            // Listener para Membros
            onSnapshot(MEMBERS_COLLECTION, (snapshot) => {
                // Assume que todos os nomes estão no documento 'default-members'
                const defaultMembersDoc = snapshot.docs.find(doc => doc.id === 'default-members');
                if (defaultMembersDoc) {
                    members = defaultMembersDoc.data().names || [];
                    setupDatalistLogic();
                } else {
                    // Inicializa os membros se não existirem
                    initializeMembers();
                }
            }, (error) => {
                console.error("Erro ao ler lista de membros:", error);
                // A regra de segurança de LEITURA deve ser if true!
            });

            // Listener para a escala (para garantir que a leitura inicial seja sempre feita)
            // A leitura da escala é tratada em setupScheduleListener, mas garantimos que as operações de escrita
            // na inicialização (initializeSchedule e initializeMembers) lidem com a falta de permissão.
        };

        /** Configura o listener para a Escala do mês/ano atual */
        const setupScheduleListener = async (month, year) => {
            // 1. Tenta inicializar a escala se não existir.
            // A inicialização é crucial e deve ser tentada, mas com tratamento de erro.
            if (auth.currentUser) {
                 await initializeSchedule(month, year);
            }
           
            // 2. Configura o listener de leitura em tempo real
            const docId = getScheduleDocId(month, year);
            const docRef = doc(SCHEDULE_COLLECTION, docId);
            
            onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    const cultos = docSnap.data().cultos || [];
                    renderSchedule(cultos);
                } else {
                    // Se o documento foi excluído, renderiza vazio
                    renderSchedule([]); 
                }
            }, (error) => {
                // Este erro também acontecerá se a leitura não for 'if true'
                showStatus(`Erro ao carregar a escala: Verifique as regras de leitura pública do Firestore.`, true);
                console.error("Erro no listener da escala:", error);
            });
        };
        
        // --- Lógica de UI/Seletores ---

        const populateSelectors = () => {
            const current = new Date();
            const startYear = current.getFullYear() - 1;
            const endYear = current.getFullYear() + 5;

            // Anos
            for (let y = startYear; y <= endYear; y++) {
                const option = document.createElement('option');
                option.value = y;
                option.textContent = y;
                if (y === currentYear) option.selected = true;
                yearSelector.appendChild(option);
            }

            // Meses
            for (let m = 0; m < 12; m++) {
                const option = document.createElement('option');
                option.value = m;
                option.textContent = getMonthName(m);
                if (m === currentMonth) option.selected = true;
                monthSelector.appendChild(option);
            }
        };

        const handleSelectorChange = () => {
            currentMonth = parseInt(monthSelector.value);
            currentYear = parseInt(yearSelector.value);
            setupScheduleListener(currentMonth, currentYear);
        };

        monthSelector.addEventListener('change', handleSelectorChange);
        yearSelector.addEventListener('change', handleSelectorChange);
        
        // --- Lógica de Autenticação e Admin ---

        /** Atualiza os botões de Admin com base no estado de autenticação */
        const updateAuthButton = () => {
            if (auth.currentUser) {
                // Usuário está logado no Firebase. Assumimos que é o Admin.
                isAdmin = true;
                authButton.textContent = 'Sair Admin';
                authButton.onclick = handleSignOut;
                
                // Exibe o botão Gerenciar Escala e libera a edição
                adminManagerButton.classList.remove('hidden');
                adminManagerButton.onclick = () => document.getElementById('adminManagerModal').classList.remove('hidden');
                
            } else {
                // Usuário deslogado
                isAdmin = false;
                
                // Verifica se o Admin existe no Firestore para determinar o botão
                if (adminConfig && adminConfig.email) {
                    authButton.textContent = 'Login Admin';
                } else {
                    authButton.textContent = 'Primeiro Acesso';
                }
                authButton.onclick = () => document.getElementById('authModal').classList.remove('hidden');
                
                adminManagerButton.classList.add('hidden');
            }
            
            // Força a re-renderização para aplicar/remover contenteditable
            setupScheduleListener(currentMonth, currentYear); 
        };
        
        /** Lida com o Sign Out */
        const handleSignOut = async () => {
            try {
                await signOut(auth);
                isAdmin = false;
                showStatus('Admin deslogado com sucesso!', false);
                updateAuthButton();
            } catch (error) {
                showStatus(`Erro ao fazer logout: ${error.message}`, true);
                console.error("Erro logout:", error);
            }
        };

        /** Lida com o formulário de Login/Primeiro Acesso */
        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const email = document.getElementById('adminEmail').value;
            const password = document.getElementById('adminPassword').value;
            authSubmitButton.disabled = true;
            authSubmitButton.textContent = 'Acessando...';

            try {
                // 1. Tenta logar no Firebase
                await signInWithEmailAndPassword(auth, email, password);
                
                // 2. Se o login for bem-sucedido, verifica se o Admin foi configurado
                if (!adminConfig || !adminConfig.email) {
                    // É o primeiro acesso, salva o email do usuário
                    await setDoc(ADMIN_CONFIG_DOC, { email: email });
                }
                
                // 3. Sucesso!
                showStatus('Login Admin realizado com sucesso!', false);
                closeModal('authModal');
                authForm.reset();
            } catch (error) {
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                    // Se a conta não existe, verifica se é a primeira vez
                    if (!adminConfig || !adminConfig.email) {
                         // Se é o primeiro acesso, tenta criar o usuário
                         try {
                            await createUserWithEmailAndPassword(auth, email, password);
                            await setDoc(ADMIN_CONFIG_DOC, { email: email });
                            showStatus('Primeiro Admin configurado e logado!', false);
                            closeModal('authModal');
                            authForm.reset();
                         } catch (createError) {
                            showStatus(`Erro ao criar conta: ${createError.message}. Verifique as permissões de Auth.`, true);
                         }
                    } else {
                        showStatus('Email ou senha incorretos.', true);
                    }
                } else {
                    showStatus(`Erro de Login: ${error.message}`, true);
                }
            } finally {
                authSubmitButton.disabled = false;
                authSubmitButton.textContent = 'Acessar';
            }
        });
        
        // --- Lógica do Modal de Gerenciamento ---

        /** Renderiza a lista de membros no modal */
        const renderMembersList = () => {
            membersListContainer.innerHTML = members.map(name => `
                <div class="flex justify-between items-center p-2 bg-white rounded-md shadow-sm border border-gray-200">
                    <span class="text-gray-800">${name}</span>
                    <button onclick="removeMember('${name}')" class="text-red-500 hover:text-red-700 font-semibold text-sm transition duration-150">
                        Remover
                    </button>
                </div>
            `).join('');
        };
        
        /** Adiciona novo membro */
        addMemberButton.addEventListener('click', async () => {
            const newName = newMemberNameInput.value.trim();
            if (newName && !members.includes(newName)) {
                members.push(newName);
                await setDoc(doc(MEMBERS_COLLECTION, 'default-members'), { names: members });
                newMemberNameInput.value = '';
                showStatus(`Membro ${newName} adicionado!`, false);
            }
        });

        /** Remove membro */
        window.removeMember = async (nameToRemove) => {
            if (!window.confirm(`Tem certeza que deseja remover ${nameToRemove} da lista?`)) return;
            members = members.filter(name => name !== nameToRemove);
            await setDoc(doc(MEMBERS_COLLECTION, 'default-members'), { names: members });
            showStatus(`Membro ${nameToRemove} removido!`, false);
        };
        
        /** Adiciona novo culto manualmente */
        document.getElementById('addCultoForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const dateInput = document.getElementById('cultoDate').value;
            const cultoName = document.getElementById('cultoName').value.trim();
            
            if (!dateInput || !cultoName) return;

            const date = new Date(dateInput + 'T00:00:00'); // Garante que a data é tratada como local/meia-noite
            const month = date.getMonth();
            const year = date.getFullYear();
            const day = date.getDay();

            // Verifica se a data pertence ao mês/ano selecionado
            if (month !== currentMonth || year !== currentYear) {
                showStatus("A data do culto deve ser do mês e ano atualmente selecionados.", true);
                return;
            }

            const docId = getScheduleDocId(month, year);
            const docRef = doc(SCHEDULE_COLLECTION, docId);

            const dateString = `${String(date.getDate()).padStart(2, '0')}/${String(month + 1).padStart(2, '0')}/${year}`;
            const cultoId = `${year}-${String(month + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}-${day}-manual`;

            const newCulto = {
                id: cultoId,
                date: dateString,
                day: getDayName(day),
                culto: cultoName,
                portaria: "A DEFINIR",
                direcao: "A DEFINIR",
                preletor: "A DEFINIR",
                timestamp: date.getTime(),
                week: getWeekNumber(date)
            };

            try {
                const docSnap = await getDoc(docRef);
                let cultos = [];
                if (docSnap.exists()) {
                    cultos = docSnap.data().cultos || [];
                }
                
                // Evita duplicatas
                if (cultos.some(c => c.id === newCulto.id)) {
                    showStatus("Culto já existe nesta data/dia.", true);
                    return;
                }

                cultos.push(newCulto);
                await setDoc(docRef, { cultos: cultos });
                showStatus("Novo culto adicionado com sucesso!", false);
                document.getElementById('addCultoForm').reset();
            } catch (error) {
                showStatus(`Erro ao adicionar culto: ${error.message}`, true);
            }
        });

        /** Lógica para atualizar Email/Senha do Admin */
        document.getElementById('updateAdminForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const newEmail = document.getElementById('adminNewEmail').value.trim();
            const newPassword = document.getElementById('adminNewPassword').value.trim();
            const updateStatusEl = document.getElementById('updateStatus');
            
            updateStatusEl.textContent = 'Atualizando...';
            updateStatusEl.classList.remove('text-green-600', 'text-red-600');
            
            try {
                let successMessage = [];

                if (newEmail) {
                    await updateEmail(auth.currentUser, newEmail);
                    await updateDoc(ADMIN_CONFIG_DOC, { email: newEmail });
                    successMessage.push('Email atualizado.');
                }
                
                if (newPassword) {
                    if (newPassword.length < 6) {
                        throw new Error("A senha deve ter pelo menos 6 caracteres.");
                    }
                    await updatePassword(auth.currentUser, newPassword);
                    successMessage.push('Senha atualizada.');
                }
                
                if (successMessage.length > 0) {
                    updateStatusEl.textContent = successMessage.join(' ');
                    updateStatusEl.classList.add('text-green-600');
                    document.getElementById('updateAdminForm').reset();
                } else {
                    updateStatusEl.textContent = 'Nenhuma alteração realizada.';
                }
                
            } catch (error) {
                updateStatusEl.textContent = `Erro ao atualizar: ${error.message}. Faça login novamente para reautenticar.`;
                updateStatusEl.classList.add('text-red-600');
                console.error("Erro ao atualizar credenciais:", error);
            }
        });

        // --- Inicialização do App ---

        const startApp = () => {
            // 1. Configura os seletores de data para o mês/ano atual
            populateSelectors();
            
            // 2. Configura a escuta de autenticação do Firebase
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    // Usuário autenticado
                    updateAuthButton();
                } else {
                    // Usuário deslogado
                    updateAuthButton();
                }
                // Garante que o listener da escala seja configurado após a autenticação inicial
                setupScheduleListener(currentMonth, currentYear);
            }, (error) => {
                 // Este erro geralmente é o 'auth/admin-restricted-operation' que indica que
                 // o signInAnonymously falhou devido à desativação no console
                 console.error("Erro na autenticação inicial:", error);
                 showStatus(`Erro fatal ao iniciar o aplicativo: Falha na autenticação inicial. ${error.message}`, true);
            });
            
            // 3. Configura listeners globais (Membros e Config Admin)
            setupGlobalListeners();
        };

        // Escuta os eventos para o modal de Gerenciamento (renderiza lista de membros)
        adminManagerModal.addEventListener('transitionend', () => {
            if (!adminManagerModal.classList.contains('hidden')) {
                renderMembersList();
            }
        });


        // Inicia o aplicativo ao carregar o script
        startApp();

    </script>
</body>
</html>
